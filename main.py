
import os
import csv
import json
from io import StringIO
from flask import (
    Flask,
    Blueprint,
    render_template,
    request,
    redirect,
    url_for,
    flash,
    session,
    jsonify
)
from werkzeug.utils import secure_filename
from dotenv import load_dotenv
import google.generativeai as genai
import pydicom
import numpy as np
from PIL import Image
import fitz  # PyMuPDF
import markdown

load_dotenv()

main_blueprint = Blueprint("main", __name__, template_folder="templates")

# --- Performance Improvement: Initialize Model Once ---
genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
model = genai.GenerativeModel('gemini-1.5-flash-latest')
# -----------------------------------------------------

UPLOAD_FOLDER = "src/uploads"
ALLOWED_EXTENSIONS = {"txt", "pdf", "png", "jpg", "jpeg", "gif", "dcm", "csv"}

# AI-generated content disclaimer
disclaimer = """
***
**Disclaimer:** This analysis is generated by an AI and is for informational purposes only. It is not a substitute for professional medical advice, diagnosis, or treatment. Always seek the advice of your physician or other qualified health provider with any questions you may have regarding a medical condition. Never disregard professional medical advice or delay in seeking it because of something you have read here.
"""

def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS

# --- Rigorous Prompt for Accuracy ---
base_prompt_text = f"""
You are a meticulous and highly accurate clinical lab analyst. Your primary goal is precision and providing a clear, nuanced interpretation of medical data.

**Pre-Analysis (Internal Thought Process - Do Not Include in Final Output):**
Before generating the response, you must perform a silent pre-analysis for each test result. For each test, follow these steps:
1.  **Identify:** Find the test name, its value, and the normal range.
2.  **Categorize:**
    *   Is the value **below** the normal range?
    *   Is the value **within** the normal range?
    *   Is the value **above** the normal range?
3.  **Sub-Categorize (if within range):**
    *   If the value is in the bottom 25% of the normal range, note it as "Lower Limit".
    *   If the value is in the top 25% of the normal range, note it as "Upper Limit".
4.  **Sub-Categorize (if outside range):**
    *   If the value is only slightly outside the range (e.g., within 5% of the closest boundary), note it as "Slightly Low" or "Slightly High".
5.  **Decide Interpretation:** Based on your categorization, determine the final interpretation string according to the strict guidelines below.

**Final Output Structure:**

Analyze the following medical document and provide a comprehensive clinical analysis in the structured format below. Your output **must** be a valid markdown table.

**1. Clinical Analysis (Tabular Format):**
   - Present the results in a markdown table wrapped in a `div` with the class `responsive-table-container`.
   - **CRITICAL: Adhere strictly to your pre-analysis and the interpretation guidelines.**

   - **Interpretation Guidelines & Formatting:**
     - **Normal:** Value is within the middle 50% of the range. Interpretation: `Normal`
     - **Normal (Lower Limit):** Value is within the bottom 25% of the range. Interpretation: `Normal (Lower Limit)`
     - **Normal (Upper Limit):** Value is within the top 25% of the range. Interpretation: `Normal (Upper Limit)`
     - **Abnormal (Slightly Low/High):** Value is slightly outside the range. Interpretation: `<span class="interpretation-abnormal">**Abnormal (Slightly Low/High)**</span>`
     - **Abnormal (Low/High):** Value is significantly outside the range. Interpretation: `<span class="interpretation-abnormal">**Abnormal (Low/High)**</span>`

   - **Example Table Format (This is a strict template):**
     | Test                      | Value   | Normal Range      | Interpretation                                                    |
     |---------------------------|---------|-------------------|-------------------------------------------------------------------|
     | RDW                       | 15.0%   | 11.5 - 15.0 %     | Normal (Upper Limit)                                              |
     | Absolute Monocyte Count   | 196.8   | 200 - 1000 /cu.mm | <span class="interpretation-abnormal">**Abnormal (Slightly Low)**</span> |
     | Platelet Count            | 155000  | 150000-450000/cmm | Normal (Lower Limit)                                              |
     | Glucose                   | 150     | 70-100 mg/dL      | <span class="interpretation-abnormal">**Abnormal (High)**</span>       |

**2. Summary of Findings:**
   - A detailed interpretation of the overall findings, paying close attention to borderline or slightly abnormal results, as identified in your pre-analysis.
   - Potential diagnoses and differential diagnoses.
   - Identification of any urgent or critical results.

**3. Suggested Prescription:**
   - Recommend a potential course of medication, including drug names, dosages, and frequencies, based on the report's findings.
   - **IMPORTANT: State clearly that this is a suggestion and must be verified by a licensed physician.**

**4. Recommended Diet Plan:**
   - Provide a sample diet plan tailored to the clinical findings.
   - Include suggestions for foods to eat and foods to avoid.

Finally, include the following disclaimer at the end of your entire response:
{disclaimer}

Here is the document content:
"""
# -------------------------------------


@main_blueprint.route("/")
def index():
    session.clear()
    return render_template("upload.html")

@main_blueprint.route("/upload", methods=["POST"])
def upload_file():
    if "file" not in request.files:
        flash("No file part")
        return redirect(request.url)
    file = request.files["file"]
    if file.filename == "":
        flash("No selected file")
        return redirect(request.url)
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        if not os.path.exists(UPLOAD_FOLDER):
            os.makedirs(UPLOAD_FOLDER)
        file_path = os.path.join(UPLOAD_FOLDER, filename)
        file.save(file_path)
        flash("File successfully uploaded")
        session['file_path'] = file_path
        return redirect(url_for("main.analyze"))
    else:
        flash("Allowed file types are txt, pdf, png, jpg, jpeg, gif, dcm, csv")
        return redirect(request.url)

@main_blueprint.route("/analyze")
def analyze():
    file_path = session.get('file_path')
    if not file_path or not os.path.exists(file_path):
        flash("File not found or session expired.")
        return redirect(url_for("main.index"))

    try:
        chat = model.start_chat(history=[])
        
        img = None
        content = None
        prompt = None

        if file_path.lower().endswith((".png", ".jpg", ".jpeg", ".gif", ".dcm")):
            if file_path.lower().endswith(".dcm"):
                ds = pydicom.dcmread(file_path)
                pixel_array = ds.pixel_array
                if pixel_array.dtype != np.uint8:
                    pixel_array = pixel_array.astype(float)
                    pixel_array = (np.maximum(pixel_array, 0) / pixel_array.max()) * 255.0
                    pixel_array = np.uint8(pixel_array)
                img = Image.fromarray(pixel_array)
            else:
                img = Image.open(file_path)
            
            prompt = f"""
Analyze the following medical image. Provide a comprehensive clinical analysis, including the following sections:

**1. Clinical Analysis:**
   - A detailed interpretation of the visual findings.
   - Potential diagnoses and differential diagnoses based on the image.
   - Identification of any anomalies or critical areas.

**2. Suggested Next Steps (No Prescription from Image Alone):**
   - Based on the image, what are the recommended next steps for diagnosis or treatment?
   - Note that a prescription cannot be provided from an image alone.

**3. General Health & Diet Recommendations:**
   - Provide general health and diet advice that may be relevant to the findings in the image.

Finally, include the following disclaimer at the end of your entire response:
{disclaimer}
"""
            full_prompt = [prompt, img]

        else:
            if file_path.lower().endswith(".pdf"):
                with fitz.open(file_path) as doc:
                    content = "".join(page.get_text() for page in doc)
            elif file_path.lower().endswith(".txt"):
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            else:
                flash("Unsupported file type for analysis.")
                return redirect(url_for("main.index"))

            prompt = f"{base_prompt_text}\n\n{content}"
            full_prompt = [prompt]

        response = chat.send_message(full_prompt)
        analysis_html = markdown.markdown(response.text)
        session['chat_history'] = [message_to_dict(m) for m in chat.history]
        return render_template("results.html", analysis=analysis_html)

    except Exception as e:
        flash(f"An error occurred during analysis: {e}")
        return redirect(url_for("main.index"))

@main_blueprint.route("/chat", methods=["POST"])
def chat():
    user_message = request.json.get("message")
    if not user_message:
        return jsonify({"error": "No message provided"}), 400

    try:
        # --- New Chat Scoping and Persona Prompt ---
        chat_instruction_prompt = """
        **SYSTEM_RULE:** You are a helpful and knowledgeable medical assistant.
        Your **only** role is to answer user questions based on the detailed medical report analysis already present in our conversation history.

        **CRITICAL CHAT RULES:**
        1.  **STAY ON TOPIC:** Your entire focus is the medical report. Answer questions about the results, diet, exercise, and health recommendations based on that report.
        2.  **USE THE HISTORY:** The full medical report and its initial analysis are in the chat history. Refer to it to answer questions.
        3.  **DECLINE OFF-TOPIC QUESTIONS:** If the user asks about anything not related to their medical report (e.g., politics, coding, weather, general knowledge), you **MUST** politely refuse. A perfect response would be: "My role is to assist you with your medical report. I cannot answer questions outside of that scope. How can I help you with your analysis?"
        4.  **BE CONCISE:** Provide direct answers to the user's questions without re-stating the entire report.
        """
        # --------------------------------------------

        history = session.get('chat_history', [])
        if not history:
            return jsonify({"error": "No chat history found. Please analyze a report first."}), 400

        history_from_dict = [dict_to_message(m) for m in history]

        chat = model.start_chat(history=history_from_dict)

        # Combine the strict instructions with the user's message
        full_user_message = f"{chat_instruction_prompt}\n\n**User Question:** \"{user_message}\""

        response = chat.send_message(full_user_message)
        model_response_html = markdown.markdown(response.text)

        # Update session with the latest history
        session['chat_history'] = [message_to_dict(m) for m in chat.history]

        return jsonify({"response": model_response_html})

    except Exception as e:
        return jsonify({"error": str(e)}), 500


@main_blueprint.route("/lab_data", methods=["GET"])
def lab_data():
    return render_template("lab_data.html")

@main_blueprint.route("/analyze_lab_data", methods=["POST"])
def analyze_lab_data():
    lab_data_content = ""
    if 'csv_file' in request.files:
        csv_file = request.files['csv_file']
        if csv_file.filename != '' and allowed_file(csv_file.filename):
            stream = StringIO(csv_file.stream.read().decode("UTF8"), newline=None)
            csv_reader = csv.reader(stream)
            lab_data_content = "\n".join([",".join(row) for row in csv_reader])

    manual_data = request.form.get('manual_data')
    if manual_data:
        lab_data_content += "\n" + manual_data

    if not lab_data_content.strip():
        flash("No lab data provided.")
        return redirect(url_for("main.lab_data"))

    try:
        chat = model.start_chat(history=[])
        
        prompt = f"{base_prompt_text}\n\n{lab_data_content}"
        
        response = chat.send_message(prompt)
        analysis_html = markdown.markdown(response.text)
        session['chat_history'] = [message_to_dict(m) for m in chat.history]
        return render_template("results.html", analysis=analysis_html)

    except Exception as e:
        flash(f"An error occurred during lab data analysis: {e}")
        return redirect(url_for("main.lab_data"))

@main_blueprint.route("/ocr_data", methods=["GET"])
def ocr_data():
    return render_template("ocr_data.html")

@main_blueprint.route("/analyze_ocr_data", methods=["POST"])
def analyze_ocr_data():
    ocr_data = request.form.get("ocr_data")
    if not ocr_data or not ocr_data.strip():
        flash("No OCR data provided.")
        return redirect(url_for("main.ocr_data"))

    extracted_text = ""
    try:
        data = json.loads(ocr_data)
        if isinstance(data, list):
            extracted_text = ' '.join(item.get('text', '') for item in data if isinstance(item, dict))
        else:
            extracted_text = ocr_data
    except json.JSONDecodeError:
        extracted_text = ocr_data

    if not extracted_text.strip():
        flash("Could not extract any text from the provided data.")
        return redirect(url_for("main.ocr_data"))

    try:
        chat = model.start_chat(history=[])
        
        prompt = f"{base_prompt_text}\n\n{extracted_text}"
        
        response = chat.send_message(prompt)
        analysis_html = markdown.markdown(response.text)
        session['chat_history'] = [message_to_dict(m) for m in chat.history]
        return render_template("results.html", analysis=analysis_html)

    except Exception as e:
        flash(f"An error occurred during OCR data analysis: {e}")
        return redirect(url_for("main.ocr_data"))

def message_to_dict(message):
    return {'role': message.role, 'parts': [part.text for part in message.parts]}

def dict_to_message(d):
    return {'role': d['role'], 'parts': d['parts']}

def create_app():
    app = Flask(__name__, static_folder="src/static", template_folder="src/templates")
    app.config["SECRET_KEY"] = os.environ.get("SECRET_KEY", "dev")
    app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER
    app.register_blueprint(main_blueprint)
    return app

if __name__ == "__main__":
    app = create_app()
    app.run(debug=True)
